/**
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.os;


/**
 * RecoverySystem contains methods for interacting with the Android
 * recovery system (the separate partition that can be used to install
 * system updates, wipe user data, etc.)
 */
public class RecoverySystem {
    private static final java.lang.String TAG = "RecoverySystem";

    /**
     * Default location of zip file containing public keys (X509
     * certs) authorized to sign OTA updates.
     */
    private static final java.io.File DEFAULT_KEYSTORE = new java.io.File("/system/etc/security/otacerts.zip");

    /**
     * Send progress to listeners no more often than this (in ms).
     */
    private static final long PUBLISH_PROGRESS_INTERVAL_MS = 500;

    /**
     * Used to communicate with recovery.  See bootable/recovery/recovery.cpp.
     */
    private static final java.io.File RECOVERY_DIR = new java.io.File("/cache/recovery");

    private static final java.io.File LOG_FILE = new java.io.File(android.os.RecoverySystem.RECOVERY_DIR, "log");

    private static final java.io.File LAST_INSTALL_FILE = new java.io.File(android.os.RecoverySystem.RECOVERY_DIR, "last_install");

    private static final java.lang.String LAST_PREFIX = "last_";

    /**
     * The recovery image uses this file to identify the location (i.e. blocks)
     * of an OTA package on the /data partition. The block map file is
     * generated by uncrypt.
     *
     * @unknown 
     */
    public static final java.io.File BLOCK_MAP_FILE = new java.io.File(android.os.RecoverySystem.RECOVERY_DIR, "block.map");

    /**
     * UNCRYPT_PACKAGE_FILE stores the filename to be uncrypt'd, which will be
     * read by uncrypt.
     *
     * @unknown 
     */
    public static final java.io.File UNCRYPT_PACKAGE_FILE = new java.io.File(android.os.RecoverySystem.RECOVERY_DIR, "uncrypt_file");

    /**
     * UNCRYPT_STATUS_FILE stores the time cost (and error code in the case of a failure)
     * of uncrypt.
     *
     * @unknown 
     */
    public static final java.io.File UNCRYPT_STATUS_FILE = new java.io.File(android.os.RecoverySystem.RECOVERY_DIR, "uncrypt_status");

    // Length limits for reading files.
    private static final int LOG_FILE_MAX_LENGTH = 64 * 1024;

    // Prevent concurrent execution of requests.
    private static final java.lang.Object sRequestLock = new java.lang.Object();

    private final android.os.IRecoverySystem mService;

    /**
     * Interface definition for a callback to be invoked regularly as
     * verification proceeds.
     */
    public interface ProgressListener {
        /**
         * Called periodically as the verification progresses.
         *
         * @param progress
         * 		the approximate percentage of the
         * 		verification that has been completed, ranging from 0
         * 		to 100 (inclusive).
         */
        public void onProgress(int progress);
    }

    /**
     *
     *
     * @return the set of certs that can be used to sign an OTA package.
     */
    private static java.util.HashSet<java.security.cert.X509Certificate> getTrustedCerts(java.io.File keystore) throws java.io.IOException, java.security.GeneralSecurityException {
        java.util.HashSet<java.security.cert.X509Certificate> trusted = new java.util.HashSet<java.security.cert.X509Certificate>();
        if (keystore == null) {
            keystore = android.os.RecoverySystem.DEFAULT_KEYSTORE;
        }
        java.util.zip.ZipFile zip = new java.util.zip.ZipFile(keystore);
        try {
            java.security.cert.CertificateFactory cf = java.security.cert.CertificateFactory.getInstance("X.509");
            java.util.Enumeration<? extends java.util.zip.ZipEntry> entries = zip.entries();
            while (entries.hasMoreElements()) {
                java.util.zip.ZipEntry entry = entries.nextElement();
                java.io.InputStream is = zip.getInputStream(entry);
                try {
                    trusted.add(((java.security.cert.X509Certificate) (cf.generateCertificate(is))));
                } finally {
                    is.close();
                }
            } 
        } finally {
            zip.close();
        }
        return trusted;
    }

    /**
     * Verify the cryptographic signature of a system update package
     * before installing it.  Note that the package is also verified
     * separately by the installer once the device is rebooted into
     * the recovery system.  This function will return only if the
     * package was successfully verified; otherwise it will throw an
     * exception.
     *
     * Verification of a package can take significant time, so this
     * function should not be called from a UI thread.  Interrupting
     * the thread while this function is in progress will result in a
     * SecurityException being thrown (and the thread's interrupt flag
     * will be cleared).
     *
     * @param packageFile
     * 		the package to be verified
     * @param listener
     * 		an object to receive periodic progress
     * 		updates as verification proceeds.  May be null.
     * @param deviceCertsZipFile
     * 		the zip file of certificates whose
     * 		public keys we will accept.  Verification succeeds if the
     * 		package is signed by the private key corresponding to any
     * 		public key in this file.  May be null to use the system default
     * 		file (currently "/system/etc/security/otacerts.zip").
     * @throws IOException
     * 		if there were any errors reading the
     * 		package or certs files.
     * @throws GeneralSecurityException
     * 		if verification failed
     */
    public static void verifyPackage(java.io.File packageFile, android.os.RecoverySystem.ProgressListener listener, java.io.File deviceCertsZipFile) throws java.io.IOException, java.security.GeneralSecurityException {
        final long fileLen = packageFile.length();
        final java.io.RandomAccessFile raf = new java.io.RandomAccessFile(packageFile, "r");
        try {
            final long startTimeMillis = java.lang.System.currentTimeMillis();
            if (listener != null) {
                listener.onProgress(0);
            }
            raf.seek(fileLen - 6);
            byte[] footer = new byte[6];
            raf.readFully(footer);
            if ((footer[2] != ((byte) (0xff))) || (footer[3] != ((byte) (0xff)))) {
                throw new java.security.SignatureException("no signature in file (no footer)");
            }
            final int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
            final int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
            byte[] eocd = new byte[commentSize + 22];
            raf.seek(fileLen - (commentSize + 22));
            raf.readFully(eocd);
            // Check that we have found the start of the
            // end-of-central-directory record.
            if ((((eocd[0] != ((byte) (0x50))) || (eocd[1] != ((byte) (0x4b)))) || (eocd[2] != ((byte) (0x5)))) || (eocd[3] != ((byte) (0x6)))) {
                throw new java.security.SignatureException("no signature in file (bad footer)");
            }
            for (int i = 4; i < (eocd.length - 3); ++i) {
                if ((((eocd[i] == ((byte) (0x50))) && (eocd[i + 1] == ((byte) (0x4b)))) && (eocd[i + 2] == ((byte) (0x5)))) && (eocd[i + 3] == ((byte) (0x6)))) {
                    throw new java.security.SignatureException("EOCD marker found after start of EOCD");
                }
            }
            // Parse the signature
            sun.security.pkcs.PKCS7 block = new sun.security.pkcs.PKCS7(new java.io.ByteArrayInputStream(eocd, (commentSize + 22) - signatureStart, signatureStart));
            // Take the first certificate from the signature (packages
            // should contain only one).
            java.security.cert.X509Certificate[] certificates = block.getCertificates();
            if ((certificates == null) || (certificates.length == 0)) {
                throw new java.security.SignatureException("signature contains no certificates");
            }
            java.security.cert.X509Certificate cert = certificates[0];
            java.security.PublicKey signatureKey = cert.getPublicKey();
            sun.security.pkcs.SignerInfo[] signerInfos = block.getSignerInfos();
            if ((signerInfos == null) || (signerInfos.length == 0)) {
                throw new java.security.SignatureException("signature contains no signedData");
            }
            sun.security.pkcs.SignerInfo signerInfo = signerInfos[0];
            // Check that the public key of the certificate contained
            // in the package equals one of our trusted public keys.
            boolean verified = false;
            java.util.HashSet<java.security.cert.X509Certificate> trusted = android.os.RecoverySystem.getTrustedCerts(deviceCertsZipFile == null ? android.os.RecoverySystem.DEFAULT_KEYSTORE : deviceCertsZipFile);
            for (java.security.cert.X509Certificate c : trusted) {
                if (c.getPublicKey().equals(signatureKey)) {
                    verified = true;
                    break;
                }
            }
            if (!verified) {
                throw new java.security.SignatureException("signature doesn't match any trusted key");
            }
            // The signature cert matches a trusted key.  Now verify that
            // the digest in the cert matches the actual file data.
            raf.seek(0);
            final android.os.RecoverySystem.ProgressListener listenerForInner = listener;
            sun.security.pkcs.SignerInfo verifyResult = block.verify(signerInfo, new java.io.InputStream() {
                // The signature covers all of the OTA package except the
                // archive comment and its 2-byte length.
                long toRead = (fileLen - commentSize) - 2;

                long soFar = 0;

                int lastPercent = 0;

                long lastPublishTime = startTimeMillis;

                @java.lang.Override
                public int read() throws java.io.IOException {
                    throw new java.lang.UnsupportedOperationException();
                }

                @java.lang.Override
                public int read(byte[] b, int off, int len) throws java.io.IOException {
                    if (soFar >= toRead) {
                        return -1;
                    }
                    if (java.lang.Thread.currentThread().isInterrupted()) {
                        return -1;
                    }
                    int size = len;
                    if ((soFar + size) > toRead) {
                        size = ((int) (toRead - soFar));
                    }
                    int read = raf.read(b, off, size);
                    soFar += read;
                    if (listenerForInner != null) {
                        long now = java.lang.System.currentTimeMillis();
                        int p = ((int) ((soFar * 100) / toRead));
                        if ((p > lastPercent) && ((now - lastPublishTime) > android.os.RecoverySystem.PUBLISH_PROGRESS_INTERVAL_MS)) {
                            lastPercent = p;
                            lastPublishTime = now;
                            listenerForInner.onProgress(lastPercent);
                        }
                    }
                    return read;
                }
            });
            final boolean interrupted = java.lang.Thread.interrupted();
            if (listener != null) {
                listener.onProgress(100);
            }
            if (interrupted) {
                throw new java.security.SignatureException("verification was interrupted");
            }
            if (verifyResult == null) {
                throw new java.security.SignatureException("signature digest verification failed");
            }
        } finally {
            raf.close();
        }
    }

    /**
     * Process a given package with uncrypt. No-op if the package is not on the
     * /data partition.
     *
     * @param Context
     * 		the Context to use
     * @param packageFile
     * 		the package to be processed
     * @param listener
     * 		an object to receive periodic progress updates as
     * 		processing proceeds.  May be null.
     * @param handler
     * 		the Handler upon which the callbacks will be
     * 		executed.
     * @throws IOException
     * 		if there were any errors processing the package file.
     * @unknown 
     */
    @android.annotation.SystemApi
    public static void processPackage(android.content.Context context, java.io.File packageFile, final android.os.RecoverySystem.ProgressListener listener, final android.os.Handler handler) throws java.io.IOException {
        java.lang.String filename = packageFile.getCanonicalPath();
        if (!filename.startsWith("/data/")) {
            return;
        }
        android.os.RecoverySystem rs = ((android.os.RecoverySystem) (context.getSystemService(android.content.Context.RECOVERY_SERVICE)));
        android.os.IRecoverySystemProgressListener progressListener = null;
        if (listener != null) {
            final android.os.Handler progressHandler;
            if (handler != null) {
                progressHandler = handler;
            } else {
                progressHandler = new android.os.Handler(context.getMainLooper());
            }
            progressListener = new android.os.IRecoverySystemProgressListener.Stub() {
                int lastProgress = 0;

                long lastPublishTime = java.lang.System.currentTimeMillis();

                @java.lang.Override
                public void onProgress(final int progress) {
                    final long now = java.lang.System.currentTimeMillis();
                    progressHandler.post(new java.lang.Runnable() {
                        @java.lang.Override
                        public void run() {
                            if ((progress > lastProgress) && ((now - lastPublishTime) > android.os.RecoverySystem.PUBLISH_PROGRESS_INTERVAL_MS)) {
                                lastProgress = progress;
                                lastPublishTime = now;
                                listener.onProgress(progress);
                            }
                        }
                    });
                }
            };
        }
        if (!rs.uncrypt(filename, progressListener)) {
            throw new java.io.IOException("process package failed");
        }
    }

    /**
     * Process a given package with uncrypt. No-op if the package is not on the
     * /data partition.
     *
     * @param Context
     * 		the Context to use
     * @param packageFile
     * 		the package to be processed
     * @param listener
     * 		an object to receive periodic progress updates as
     * 		processing proceeds.  May be null.
     * @throws IOException
     * 		if there were any errors processing the package file.
     * @unknown 
     */
    @android.annotation.SystemApi
    public static void processPackage(android.content.Context context, java.io.File packageFile, final android.os.RecoverySystem.ProgressListener listener) throws java.io.IOException {
        android.os.RecoverySystem.processPackage(context, packageFile, listener, null);
    }

    /**
     * Reboots the device in order to install the given update
     * package.
     * Requires the {@link android.Manifest.permission#REBOOT} permission.
     *
     * @param context
     * 		the Context to use
     * @param packageFile
     * 		the update package to install.  Must be on
     * 		a partition mountable by recovery.  (The set of partitions
     * 		known to recovery may vary from device to device.  Generally,
     * 		/cache and /data are safe.)
     * @throws IOException
     * 		if writing the recovery command file
     * 		fails, or if the reboot itself fails.
     */
    public static void installPackage(android.content.Context context, java.io.File packageFile) throws java.io.IOException {
        android.os.RecoverySystem.installPackage(context, packageFile, false);
    }

    /**
     * If the package hasn't been processed (i.e. uncrypt'd), set up
     * UNCRYPT_PACKAGE_FILE and delete BLOCK_MAP_FILE to trigger uncrypt during the
     * reboot.
     *
     * @param context
     * 		the Context to use
     * @param packageFile
     * 		the update package to install.  Must be on a
     * 		partition mountable by recovery.
     * @param processed
     * 		if the package has been processed (uncrypt'd).
     * @throws IOException
     * 		if writing the recovery command file fails, or if
     * 		the reboot itself fails.
     * @unknown 
     */
    @android.annotation.SystemApi
    public static void installPackage(android.content.Context context, java.io.File packageFile, boolean processed) throws java.io.IOException {
        synchronized(android.os.RecoverySystem.sRequestLock) {
            android.os.RecoverySystem.LOG_FILE.delete();
            // Must delete the file in case it was created by system server.
            android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE.delete();
            java.lang.String filename = packageFile.getCanonicalPath();
            android.util.Log.w(android.os.RecoverySystem.TAG, ("!!! REBOOTING TO INSTALL " + filename) + " !!!");
            // If the package name ends with "_s.zip", it's a security update.
            boolean securityUpdate = filename.endsWith("_s.zip");
            // If the package is on the /data partition, the package needs to
            // be processed (i.e. uncrypt'd). The caller specifies if that has
            // been done in 'processed' parameter.
            if (filename.startsWith("/data/")) {
                if (processed) {
                    if (!android.os.RecoverySystem.BLOCK_MAP_FILE.exists()) {
                        android.util.Log.e(android.os.RecoverySystem.TAG, "Package claimed to have been processed but failed to find " + "the block map file.");
                        throw new java.io.IOException("Failed to find block map file");
                    }
                } else {
                    java.io.FileWriter uncryptFile = new java.io.FileWriter(android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE);
                    try {
                        uncryptFile.write(filename + "\n");
                    } finally {
                        uncryptFile.close();
                    }
                    // UNCRYPT_PACKAGE_FILE needs to be readable and writable
                    // by system server.
                    if ((!android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE.setReadable(true, false)) || (!android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE.setWritable(true, false))) {
                        android.util.Log.e(android.os.RecoverySystem.TAG, "Error setting permission for " + android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE);
                    }
                    android.os.RecoverySystem.BLOCK_MAP_FILE.delete();
                }
                // If the package is on the /data partition, use the block map
                // file as the package name instead.
                filename = "@/cache/recovery/block.map";
            }
            final java.lang.String filenameArg = ("--update_package=" + filename) + "\n";
            final java.lang.String localeArg = ("--locale=" + java.util.Locale.getDefault().toString()) + "\n";
            final java.lang.String securityArg = "--security\n";
            java.lang.String command = filenameArg + localeArg;
            if (securityUpdate) {
                command += securityArg;
            }
            android.os.RecoverySystem rs = ((android.os.RecoverySystem) (context.getSystemService(android.content.Context.RECOVERY_SERVICE)));
            if (!rs.setupBcb(command)) {
                throw new java.io.IOException("Setup BCB failed");
            }
            // Having set up the BCB (bootloader control block), go ahead and reboot
            android.os.PowerManager pm = ((android.os.PowerManager) (context.getSystemService(android.content.Context.POWER_SERVICE)));
            pm.reboot(android.os.PowerManager.REBOOT_RECOVERY_UPDATE);
            throw new java.io.IOException("Reboot failed (no permissions?)");
        }
    }

    /**
     * Schedule to install the given package on next boot. The caller needs to
     * ensure that the package must have been processed (uncrypt'd) if needed.
     * It sets up the command in BCB (bootloader control block), which will
     * be read by the bootloader and the recovery image.
     *
     * @param Context
     * 		the Context to use.
     * @param packageFile
     * 		the package to be installed.
     * @throws IOException
     * 		if there were any errors setting up the BCB.
     * @unknown 
     */
    @android.annotation.SystemApi
    public static void scheduleUpdateOnBoot(android.content.Context context, java.io.File packageFile) throws java.io.IOException {
        java.lang.String filename = packageFile.getCanonicalPath();
        boolean securityUpdate = filename.endsWith("_s.zip");
        // If the package is on the /data partition, use the block map file as
        // the package name instead.
        if (filename.startsWith("/data/")) {
            filename = "@/cache/recovery/block.map";
        }
        final java.lang.String filenameArg = ("--update_package=" + filename) + "\n";
        final java.lang.String localeArg = ("--locale=" + java.util.Locale.getDefault().toString()) + "\n";
        final java.lang.String securityArg = "--security\n";
        java.lang.String command = filenameArg + localeArg;
        if (securityUpdate) {
            command += securityArg;
        }
        android.os.RecoverySystem rs = ((android.os.RecoverySystem) (context.getSystemService(android.content.Context.RECOVERY_SERVICE)));
        if (!rs.setupBcb(command)) {
            throw new java.io.IOException("schedule update on boot failed");
        }
    }

    /**
     * Cancel any scheduled update by clearing up the BCB (bootloader control
     * block).
     *
     * @param Context
     * 		the Context to use.
     * @throws IOException
     * 		if there were any errors clearing up the BCB.
     * @unknown 
     */
    @android.annotation.SystemApi
    public static void cancelScheduledUpdate(android.content.Context context) throws java.io.IOException {
        android.os.RecoverySystem rs = ((android.os.RecoverySystem) (context.getSystemService(android.content.Context.RECOVERY_SERVICE)));
        if (!rs.clearBcb()) {
            throw new java.io.IOException("cancel scheduled update failed");
        }
    }

    /**
     * Reboots the device and wipes the user data and cache
     * partitions.  This is sometimes called a "factory reset", which
     * is something of a misnomer because the system partition is not
     * restored to its factory state.  Requires the
     * {@link android.Manifest.permission#REBOOT} permission.
     *
     * @param context
     * 		the Context to use
     * @throws IOException
     * 		if writing the recovery command file
     * 		fails, or if the reboot itself fails.
     * @throws SecurityException
     * 		if the current user is not allowed to wipe data.
     */
    public static void rebootWipeUserData(android.content.Context context) throws java.io.IOException {
        /* shutdown */
        /* force */
        android.os.RecoverySystem.rebootWipeUserData(context, false, context.getPackageName(), false);
    }

    /**
     * {@hide }
     */
    public static void rebootWipeUserData(android.content.Context context, java.lang.String reason) throws java.io.IOException {
        /* shutdown */
        /* force */
        android.os.RecoverySystem.rebootWipeUserData(context, false, reason, false);
    }

    /**
     * {@hide }
     */
    public static void rebootWipeUserData(android.content.Context context, boolean shutdown) throws java.io.IOException {
        /* force */
        android.os.RecoverySystem.rebootWipeUserData(context, shutdown, context.getPackageName(), false);
    }

    /**
     * Reboots the device and wipes the user data and cache
     * partitions.  This is sometimes called a "factory reset", which
     * is something of a misnomer because the system partition is not
     * restored to its factory state.  Requires the
     * {@link android.Manifest.permission#REBOOT} permission.
     *
     * @param context
     * 		the Context to use
     * @param shutdown
     * 		if true, the device will be powered down after
     * 		the wipe completes, rather than being rebooted
     * 		back to the regular system.
     * @param reason
     * 		the reason for the wipe that is visible in the logs
     * @param force
     * 		whether the {@link UserManager.DISALLOW_FACTORY_RESET} user restriction
     * 		should be ignored
     * @throws IOException
     * 		if writing the recovery command file
     * 		fails, or if the reboot itself fails.
     * @throws SecurityException
     * 		if the current user is not allowed to wipe data.
     * @unknown 
     */
    public static void rebootWipeUserData(android.content.Context context, boolean shutdown, java.lang.String reason, boolean force) throws java.io.IOException {
        android.os.UserManager um = ((android.os.UserManager) (context.getSystemService(android.content.Context.USER_SERVICE)));
        if ((!force) && um.hasUserRestriction(android.os.UserManager.DISALLOW_FACTORY_RESET)) {
            throw new java.lang.SecurityException("Wiping data is not allowed for this user.");
        }
        final android.os.ConditionVariable condition = new android.os.ConditionVariable();
        android.content.Intent intent = new android.content.Intent("android.intent.action.MASTER_CLEAR_NOTIFICATION");
        intent.addFlags(android.content.Intent.FLAG_RECEIVER_FOREGROUND);
        context.sendOrderedBroadcastAsUser(intent, android.os.UserHandle.SYSTEM, android.os.android.Manifest.permission.MASTER_CLEAR, new android.content.BroadcastReceiver() {
            @java.lang.Override
            public void onReceive(android.content.Context context, android.content.Intent intent) {
                condition.open();
            }
        }, null, 0, null, null);
        // Block until the ordered broadcast has completed.
        condition.block();
        java.lang.String shutdownArg = null;
        if (shutdown) {
            shutdownArg = "--shutdown_after";
        }
        java.lang.String reasonArg = null;
        if (!android.text.TextUtils.isEmpty(reason)) {
            reasonArg = "--reason=" + android.os.RecoverySystem.sanitizeArg(reason);
        }
        final java.lang.String localeArg = "--locale=" + java.util.Locale.getDefault().toString();
        android.os.RecoverySystem.bootCommand(context, shutdownArg, "--wipe_data", reasonArg, localeArg);
    }

    /**
     * Reboot into the recovery system to wipe the /cache partition.
     *
     * @throws IOException
     * 		if something goes wrong.
     */
    public static void rebootWipeCache(android.content.Context context) throws java.io.IOException {
        android.os.RecoverySystem.rebootWipeCache(context, context.getPackageName());
    }

    /**
     * {@hide }
     */
    public static void rebootWipeCache(android.content.Context context, java.lang.String reason) throws java.io.IOException {
        java.lang.String reasonArg = null;
        if (!android.text.TextUtils.isEmpty(reason)) {
            reasonArg = "--reason=" + android.os.RecoverySystem.sanitizeArg(reason);
        }
        final java.lang.String localeArg = "--locale=" + java.util.Locale.getDefault().toString();
        android.os.RecoverySystem.bootCommand(context, "--wipe_cache", reasonArg, localeArg);
    }

    /**
     * Reboot into recovery and wipe the A/B device.
     *
     * @param Context
     * 		the Context to use.
     * @param packageFile
     * 		the wipe package to be applied.
     * @param reason
     * 		the reason to wipe.
     * @throws IOException
     * 		if something goes wrong.
     * @unknown 
     */
    @android.annotation.SystemApi
    public static void rebootWipeAb(android.content.Context context, java.io.File packageFile, java.lang.String reason) throws java.io.IOException {
        java.lang.String reasonArg = null;
        if (!android.text.TextUtils.isEmpty(reason)) {
            reasonArg = "--reason=" + android.os.RecoverySystem.sanitizeArg(reason);
        }
        final java.lang.String filename = packageFile.getCanonicalPath();
        final java.lang.String filenameArg = "--wipe_package=" + filename;
        final java.lang.String localeArg = "--locale=" + java.util.Locale.getDefault().toString();
        android.os.RecoverySystem.bootCommand(context, "--wipe_ab", filenameArg, reasonArg, localeArg);
    }

    /**
     * Reboot into the recovery system with the supplied argument.
     *
     * @param args
     * 		to pass to the recovery utility.
     * @throws IOException
     * 		if something goes wrong.
     */
    private static void bootCommand(android.content.Context context, java.lang.String... args) throws java.io.IOException {
        android.os.RecoverySystem.LOG_FILE.delete();
        java.lang.StringBuilder command = new java.lang.StringBuilder();
        for (java.lang.String arg : args) {
            if (!android.text.TextUtils.isEmpty(arg)) {
                command.append(arg);
                command.append("\n");
            }
        }
        // Write the command into BCB (bootloader control block) and boot from
        // there. Will not return unless failed.
        android.os.RecoverySystem rs = ((android.os.RecoverySystem) (context.getSystemService(android.content.Context.RECOVERY_SERVICE)));
        rs.rebootRecoveryWithCommand(command.toString());
        throw new java.io.IOException("Reboot failed (no permissions?)");
    }

    // Read last_install; then report time (in seconds) and I/O (in MiB) for
    // this update to tron.
    // Only report on the reboots immediately after an OTA update.
    private static void parseLastInstallLog(android.content.Context context) {
        try (java.io.BufferedReader in = new java.io.BufferedReader(new java.io.FileReader(android.os.RecoverySystem.LAST_INSTALL_FILE))) {
            java.lang.String line = null;
            int bytesWrittenInMiB = -1;
            int bytesStashedInMiB = -1;
            int timeTotal = -1;
            int uncryptTime = -1;
            int sourceVersion = -1;
            while ((line = in.readLine()) != null) {
                // Here is an example of lines in last_install:
                // ...
                // time_total: 101
                // bytes_written_vendor: 51074
                // bytes_stashed_vendor: 200
                int numIndex = line.indexOf(':');
                if ((numIndex == (-1)) || ((numIndex + 1) >= line.length())) {
                    continue;
                }
                java.lang.String numString = line.substring(numIndex + 1).trim();
                long parsedNum;
                try {
                    parsedNum = java.lang.Long.parseLong(numString);
                } catch (java.lang.NumberFormatException ignored) {
                    android.util.Log.e(android.os.RecoverySystem.TAG, "Failed to parse numbers in " + line);
                    continue;
                }
                final int MiB = 1024 * 1024;
                int scaled;
                try {
                    if (line.startsWith("bytes")) {
                        scaled = java.lang.Math.toIntExact(parsedNum / MiB);
                    } else {
                        scaled = java.lang.Math.toIntExact(parsedNum);
                    }
                } catch (java.lang.ArithmeticException ignored) {
                    android.util.Log.e(android.os.RecoverySystem.TAG, "Number overflows in " + line);
                    continue;
                }
                if (line.startsWith("time")) {
                    timeTotal = scaled;
                } else
                    if (line.startsWith("uncrypt_time")) {
                        uncryptTime = scaled;
                    } else
                        if (line.startsWith("source_build")) {
                            sourceVersion = scaled;
                        } else
                            if (line.startsWith("bytes_written")) {
                                bytesWrittenInMiB = (bytesWrittenInMiB == (-1)) ? scaled : bytesWrittenInMiB + scaled;
                            } else
                                if (line.startsWith("bytes_stashed")) {
                                    bytesStashedInMiB = (bytesStashedInMiB == (-1)) ? scaled : bytesStashedInMiB + scaled;
                                }




            } 
            // Don't report data to tron if corresponding entry isn't found in last_install.
            if (timeTotal != (-1)) {
                com.android.internal.logging.MetricsLogger.histogram(context, "ota_time_total", timeTotal);
            }
            if (uncryptTime != (-1)) {
                com.android.internal.logging.MetricsLogger.histogram(context, "ota_uncrypt_time", uncryptTime);
            }
            if (sourceVersion != (-1)) {
                com.android.internal.logging.MetricsLogger.histogram(context, "ota_source_version", sourceVersion);
            }
            if (bytesWrittenInMiB != (-1)) {
                com.android.internal.logging.MetricsLogger.histogram(context, "ota_written_in_MiBs", bytesWrittenInMiB);
            }
            if (bytesStashedInMiB != (-1)) {
                com.android.internal.logging.MetricsLogger.histogram(context, "ota_stashed_in_MiBs", bytesStashedInMiB);
            }
        } catch (java.io.IOException e) {
            android.util.Log.e(android.os.RecoverySystem.TAG, "Failed to read lines in last_install", e);
        }
    }

    /**
     * Called after booting to process and remove recovery-related files.
     *
     * @return the log file from recovery, or null if none was found.
     * @unknown 
     */
    public static java.lang.String handleAftermath(android.content.Context context) {
        // Record the tail of the LOG_FILE
        java.lang.String log = null;
        try {
            log = android.os.FileUtils.readTextFile(android.os.RecoverySystem.LOG_FILE, -android.os.RecoverySystem.LOG_FILE_MAX_LENGTH, "...\n");
        } catch (java.io.FileNotFoundException e) {
            android.util.Log.i(android.os.RecoverySystem.TAG, "No recovery log file");
        } catch (java.io.IOException e) {
            android.util.Log.e(android.os.RecoverySystem.TAG, "Error reading recovery log", e);
        }
        if (log != null) {
            android.os.RecoverySystem.parseLastInstallLog(context);
        }
        // Only remove the OTA package if it's partially processed (uncrypt'd).
        boolean reservePackage = android.os.RecoverySystem.BLOCK_MAP_FILE.exists();
        if ((!reservePackage) && android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE.exists()) {
            java.lang.String filename = null;
            try {
                filename = android.os.FileUtils.readTextFile(android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE, 0, null);
            } catch (java.io.IOException e) {
                android.util.Log.e(android.os.RecoverySystem.TAG, "Error reading uncrypt file", e);
            }
            // Remove the OTA package on /data that has been (possibly
            // partially) processed. (Bug: 24973532)
            if ((filename != null) && filename.startsWith("/data")) {
                if (android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE.delete()) {
                    android.util.Log.i(android.os.RecoverySystem.TAG, "Deleted: " + filename);
                } else {
                    android.util.Log.e(android.os.RecoverySystem.TAG, "Can't delete: " + filename);
                }
            }
        }
        // We keep the update logs (beginning with LAST_PREFIX), and optionally
        // the block map file (BLOCK_MAP_FILE) for a package. BLOCK_MAP_FILE
        // will be created at the end of a successful uncrypt. If seeing this
        // file, we keep the block map file and the file that contains the
        // package name (UNCRYPT_PACKAGE_FILE). This is to reduce the work for
        // GmsCore to avoid re-downloading everything again.
        java.lang.String[] names = android.os.RecoverySystem.RECOVERY_DIR.list();
        for (int i = 0; (names != null) && (i < names.length); i++) {
            if (names[i].startsWith(android.os.RecoverySystem.LAST_PREFIX))
                continue;

            if (reservePackage && names[i].equals(android.os.RecoverySystem.BLOCK_MAP_FILE.getName()))
                continue;

            if (reservePackage && names[i].equals(android.os.RecoverySystem.UNCRYPT_PACKAGE_FILE.getName()))
                continue;

            android.os.RecoverySystem.recursiveDelete(new java.io.File(android.os.RecoverySystem.RECOVERY_DIR, names[i]));
        }
        return log;
    }

    /**
     * Internally, delete a given file or directory recursively.
     */
    private static void recursiveDelete(java.io.File name) {
        if (name.isDirectory()) {
            java.lang.String[] files = name.list();
            for (int i = 0; (files != null) && (i < files.length); i++) {
                java.io.File f = new java.io.File(name, files[i]);
                android.os.RecoverySystem.recursiveDelete(f);
            }
        }
        if (!name.delete()) {
            android.util.Log.e(android.os.RecoverySystem.TAG, "Can't delete: " + name);
        } else {
            android.util.Log.i(android.os.RecoverySystem.TAG, "Deleted: " + name);
        }
    }

    /**
     * Talks to RecoverySystemService via Binder to trigger uncrypt.
     */
    private boolean uncrypt(java.lang.String packageFile, android.os.IRecoverySystemProgressListener listener) {
        try {
            return mService.uncrypt(packageFile, listener);
        } catch (android.os.RemoteException unused) {
        }
        return false;
    }

    /**
     * Talks to RecoverySystemService via Binder to set up the BCB.
     */
    private boolean setupBcb(java.lang.String command) {
        try {
            return mService.setupBcb(command);
        } catch (android.os.RemoteException unused) {
        }
        return false;
    }

    /**
     * Talks to RecoverySystemService via Binder to clear up the BCB.
     */
    private boolean clearBcb() {
        try {
            return mService.clearBcb();
        } catch (android.os.RemoteException unused) {
        }
        return false;
    }

    /**
     * Talks to RecoverySystemService via Binder to set up the BCB command and
     * reboot into recovery accordingly.
     */
    private void rebootRecoveryWithCommand(java.lang.String command) {
        try {
            mService.rebootRecoveryWithCommand(command);
        } catch (android.os.RemoteException ignored) {
        }
    }

    /**
     * Internally, recovery treats each line of the command file as a separate
     * argv, so we only need to protect against newlines and nulls.
     */
    private static java.lang.String sanitizeArg(java.lang.String arg) {
        arg = arg.replace('\u0000', '?');
        arg = arg.replace('\n', '?');
        return arg;
    }

    /**
     *
     *
     * @unknown Was previously made visible by accident.
     */
    public RecoverySystem() {
        mService = null;
    }

    /**
     *
     *
     * @unknown 
     */
    public RecoverySystem(android.os.IRecoverySystem service) {
        mService = service;
    }
}

